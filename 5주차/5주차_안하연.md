# 👩‍💻 목차
* [11장 제트팩 라이브러리](#11장-제트팩-라이브러리)
    - [11-1 제트팩, androidx 소개](#11-1-제트팩-androidx-소개)
    - [11-2 appcompat 라이브러리](#11-2-appcompat-라이브러리)
    - [11-3 프래그먼트](#11-3-프래그먼트)
    - [11-4 리사이클러 뷰](#11-4-리사이클러-뷰)
    - [11-5 뷰 페이저2](#11-5-뷰-페이저2)
    - [11-6 드로어 레이아웃](#11-6-드로어-레이아웃)

<br>
<hr/>
<br>

# 11장 제트팩 라이브러리
## 11-1 제트팩, androidx 소개
**제트팩**
- 구글에서 제공
- 안드로이드 앱을 개발하는 데 필요한 다양한 라이브러리 모음
- 안드로이드 플랫폼이 기본으로 제공하는 플랫폼 API 외에 따로 추가된 라이브러리

<br>

### 플랫폼 API
ART(Android runtime)에서 제공하는 안드로이드 앱의 핵심 라이브러리

<br>

ART는 대부분 `android`나 `java`로 시작하는 패키지명 사용   
지금까지 살펴본 클래스의 대부분은 플랫폼 API   
플랫폼 API는 기본 재료일 뿐 실제 앱을 개발할 때는 더 다양한 기능이나 화면을 구현해야 함

<br>

### 제트팩
구글에서 안드로이드 앱 개발용으로 제공하는 다양한 라이브러리 모음   
`androidx`로 시작하는 패키지명 사용

<br>

**목적**
- 앱을 개발하는 데 필요한 권장 아키텍처 제공
- API 레벨의 호환성 문제 해결
    + 📌 목적이 같은 클래스를 *제트팩의 라이브러리에서도 제공한다면* 대부분 제트팩의 클래스 이용
- 플랫폼 API에서 제공하지 않는 다양한 기능 제공

<br>

> 📝 support 라이브러리를 통합 관리하려고 만든 개념이 androidx   
> androix는 제트팩의 구성 요소로 포함됨   
> 지금도 support 라이브러리를 사용할 순 있으나 이를 대체하는 androidx 라이브러리를 사용하는 게 좋음

<br>

### androidx 라이브러리
- **androidx.appcompat**: 앱의 API 레벨 호환성 해결
- **androidx.recylclerview**: 목록 화면 구성
- **androidx.viewpager2**: 스와이프로 넘기는 화면 구성
- **androidx.fragment**: 액티비티처럼 동작하는 뷰 제공
- **androidx.drawerlayout**: 옆에서 서랍처럼 열리는 화면 구성

<br>
<hr/>
<br>

## 11-2 appcompat 라이브러리
안드로이드 앱의 화면을 구성하는 액티비티 생성   
📌 **API 호환성 해결**

<br>

appcompat 라이브러리 사용 위해 **dependencies** 항목에 다음처럼 선언
``` kotlin
implementation 'androidx.appcompat:appcompat:1.5.1'
```

<br>

appcompat 라이브러리를 이용해 액티비티 만들 땐 플랫폼 API의 **Activity**가 아닌 appcompat의 **AppCompatAvtivity** 사용
``` kotlint
import anroidx.appcompat.app.AppCompatActivity
...
class MainActivity : AppCompatActivity() {
    ...
}
```

<br>

### 액션바
화면 위쪽에 타이틀 문자율이 출력되는 영역

<br>

액션바 기본 구성
- 내비게이션 아이콘
- 타이틀
- 액션 아이템
- 오버플로 메뉴

<br>

**색상 설정**
액션바의 색상은 이 앱에 자동으로 적용되는 테마에서 결정됨   
테마 스타일은 **res/values** 디렉터리에 있는 **themes.xml** 파일에 선언되어 있음   
선언된 스타일이 매니페스트 파일에 테마로 설정됨   
테마 파일의 각 색상값을 변경하는 것만으로도 앱의 기본 색상을 변경할 수 있음

<br>

**숨기기 설정**
액션바를 숨기는 것도 테마 파일에서 설정   
테마를 만들 때 `Theme.MaterialComponents.DayNight.NoActionBar`를 상속받으면 됨   
NoActionBar 테마를 상속받을 수 없는 상황이라면 테마의 `<item>` 속성을 다음처럼 설정
``` kotlin
<style name="테마 이름" parent="...">
    ...
    <item name="windowActionBar">false</item>
    <item name="windowNoTitle">true</item>
</style>
```

<br>

**업 버튼 설정**
**업 버튼**: 액티비티 화면이 앱의 첫 화면이 아닐 때 이전 화면으로 되돌아가는 버튼

<br>

**설정 방법**
- 액티비티가 등록되는 매니페스트 파일에서 설정
- 액티비티 코드로 설정

<br>

**메뉴 구성**
액션바의 중요한 구성 요소   
액티비티 화면에서 사용자 이벤트를 사용할 수 있도록 함   

<br>

액티비티에 메뉴를 추가하면 액션바 오른쪽에 오버플로 버튼이 나타남   
오버플로 메뉴 중 몇몇은 액션바에 **아이콘**으로 나오게 할 수 있음   
==> 이를 **액션 아이템(혹은 액션 버튼)**이라 함

<br>

**액션 뷰 이용**
**액션 뷰**: 액션바에서 특별한 기능 제공   
대표적으로 **서치 뷰**가 있음
- 액션바에서 검색 기능 제공

<br>

### 툴바
사용 목적은 액션바와 같음   
다만 액션바와 달리 툴바는 개발자가 직접 제어하는 뷰
> 📝 액션바와 툴바 차이   
> 액션바는 레이아웃 XML 파일에 작성하지 않아도 윈도우가 액션바를 자동으로 출력해줘서 편함   
> 툴바는 개발자가 직접 제어할 수 있어서 액션바보다 다양한 기능 제공 가능

<br>

툴바의 목적이 액션바와 같으므로 툴바 사용 시 액션바가 화면에 출력되지 않도록 해야함   
이후 액티비티 화면을 구성하는 레이아웃 XML 파일에 툴바 등록
``` kotlin
<androidx.appcompat.widget.Toolbar
    android:id="@+id/toolbar"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    style="@style/Widget.MaterialComponents.Toolbar.Primary" />
```
툴바 준비 이후 코드에서 액션바의 내용이 툴바에 적용되도록 지정해야 함

<br>

### 호환성을 고려한 기본 뷰 클래스
플랫폼 API에서 제공하는 기본 뷰를 appcompat 라이브러리에서도 제공

<br>
<hr/>
<br>

## 11-3 프래그먼트
액티비티 화면을 구성하는 뷰   
그 자체만으로는 화면에 아무것도 출력되지 않음   
**액티비티처럼 동작**한다는 것이 다른 뷰와의 **차이점**   
📌 액티비티에 작성할 수 있는 모든 코드는 프래그먼트에서도 사용 가능

<br>

태블릿처럼 *화면이 넓은 기기*에서 동작하는 앱을 개발할 수 있도록 제공되었음   
하지만 넓은 화면을 목적으로 하는 앱에서만 사용할 수 있는 것은 아님

<br>

**구현**
프래그먼트 화면을 구성하는 레이아웃 XML 파일을 작성해야 함   
==> 액티비티를 만들 때 레이아웃 XML 파일을 작성했던 것과 차이가 없음

<br>

`Fragment` 상속받아 작성하는 클래스   
`onCreateView()` 함수는 필수 포함

<br>

### 생명주기
액티비티와 생명주기가 같음   
액티비티의 생명주기 함수 그대로 사용 가능
- onCreate()
- onStart()
- onResume()
- onPause()
- onStop()
- onDestroy()
함수가 호출되는 시점도 액티비티와 같음

<br>

**단계**
1. 초기화
    - 프래그먼트의 화면을 구성할 뷰가 준비되지 않은 상태
2. 생성
    - 프래그먼트의 화면을 구성할 뷰 객체 준비
3. 시작
    - 프래그먼트 화면이 사용자에게 보임
4. 재개
    - 포커스를 가지고 사용자 이벤트 처리
5. 소멸

<br>

## 11-4 리사이클러 뷰
목록 화면 만들 때 사용   
**RecyclerView** 클래스만으로는 화면에 아무것도 출력되지 않음   
아래와 같은 구성 요소를 이용해야 함
- **ViewHolder**(필수): 항목에 필요한 뷰 객체를 가짐
- **Adapter**(필수): 항목 구성
- **LayoutManager**(필수): 항목 배치
- **ItemDecoration**(옵션): 항목 꾸미기

<br>

> 📝 androix에서 리사이클러 뷰를 제공하기 시작하며 목록 화면을 리스트 뷰 대신 리사이클러 뷰를 이용해 구현하기 시작   
> 리사이클러 뷰는 리스트 뷰로 만들기 어렵거나 불가능한 목록을 쉽게 만들 수 있음

<br>

리사이클러 뷰 사용 위해 리사이클러 뷰를 레이아웃 XML 파일에 등록해야 함   
또한 목록을 표시할 항목을 디자인한 레이아웃 XML 파일도 필요   
리사이클러 뷰에 어댑터와 레이아웃 매니저를 등록해 화면에 출력함

<br>

## 11-5 뷰 페이저2
스와이프 이벤트로 화면을 전환할 때 사용   
플랫폼 API에서 제공하지 않음   

<br>

레이아웃 XML 파일에 뷰 페이저2를 추가해 사용

<br>

화면을 하나의 항목으로 보며, 각 항목이 순서대로 나열되어 스와이프 할 때마다 다른 항목이 출력되는 개념   
따라서 리사이클러 뷰에서 보았던 **어댑터**를 적용해야 함
1. RecyclerView.Adapter
    - 리사이클러 뷰에서 살펴봤던 내용과 차이 없음
    - 똑같이 작성하되 뷰 페이저2의 어댑터로 적용
2. FragmentStateAdapter
    - 각 항목(화면)은 복잡하게 작성됨
    - 보통 각 항목의 내용은 프래그먼트로 작성

<br>
<hr/>
<br>

## 11-6 드로어 레이아웃
액티비티 화면에 보이지 않던 내용이 왼쪽이나 오른쪽에서 손가락의 움직임에 따라 밀려나오는 기능

<br>

액티비티 레이아웃 XML 파일 구성 중요   
레이아웃 XML 파일에서 드로어 메뉴가 출력되어야 하는 부분의 태그를 `DrawerLayout`으로 선언   
파일의 루트 태그가 꼭 **DrawerLayout**일 필요는 없으나 대부분 드로어 메뉴는 액티비티의 기본화면을 덮듯이 나오므로 루트 태그를 **DrawerLayout**으로 선언