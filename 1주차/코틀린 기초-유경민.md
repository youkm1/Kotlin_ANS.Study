1주차 

주제:장점, 차이점 그리고 코틀린의 기초 문법  by 유경민

코틀린은 우선 자바를 대체하고자 나온 언어이다. 
그러나 코틀린 또한 자바 가상 머신(JVM)을 사용한다. 

![image](https://github.com/youkm1/Kotlin_ANS.Study/assets/77780624/391f2aaf-cce5-4a71-a6e5-9033d654d172)<tr>



</tr>그렇다면 같은 머신 아래 왜 코틀린이 태어나야 했을까.


# 간결한 표현성
----
코틀린에서는 자바의 게터, 세터, 익명클래스, 명시적인 위임 등을 지양한다.

## 1. Getter/Setter
   Java는 객체의 무결성을 위해 게세터를 쓴다. 하지만 코틀린은 자동적으로 게세터가 생성된다(auto-generated Getter/Setter)
</br>따라서,
 ```Java
public class Car{
   private int car;
   public int getCar(){
      return car;
   }
   public void setCar(int car){
      if (car < 0):
         this.car = 0;
      else:
         this.car = car;
   }
}
```
⬇️

```kotlin
class Car(int car){
 // 코틀린. 개굿.
 }
```

물론, 스프링의 경우 갓Lombok가 있어서 어노테이션으로 처리가 가능하다. 
그것은 스프링의 오픈소스 라이브러리로 논외. 
</br>
## 2. 익명클래스
   익명클래스는 일회용 클래스로, 유지보수하지 않아도 될 때 쓰인다. 
Kotlin의 경우, object 키워드를 사용한다.

```kotlin
abstract class Doc{
   val title: String,
   val author: String,
   val words: Long = 0L
} {
   abstract fun summary():String
}
```
해당 클래스를 상속하는 => 익명 클래스를 만들겠다.
```kotlin
val article = object:Doc(title="매일경제", author="유경민", words="Kogood"){
   overrid fun summary() = "Title:<$title> ($words words) By $author"
}
```
class가 아닌 interface를 상속하기도 가능하다.

#  널 안정성
   객체지향에서 객체는 널 상태일 때 NullPointException이 발생한다. Kotlin에서는 변수를 널 허용(nullable)과 널 불가능(not null)으로 구분해 놓는다. 
```kotlin
var nullx: String = null //Err. default값은 not null임을 확인할 수 있음
var nullo: String? = null //nullable 위해서 물음표 필요함
```
### 코틀린에서 널 값 안전히 처리하는 방법
* if - else(모든 언어에서 통하는 문법)
   - if(nullx != null) "not null" else "null"
     
* '?.' - 안전 호출 연산자(safe call)
   - if-else문을 '?.'로 만들었다고 보면 된다.
   - null이면 수행을 건너뛰고 아닐 때는 호출된 연산을 실행한다.
     ex) ```kotlin
     val nullo: String? = null
     println(nullo?.length)
     ```
     
* '?:' - Elvis 연산자
  ```kotlin
     fun foo(node: Node): String? {
       val parent = node.getParent() ?: return null
       val name = node.getName() ?: throw IllegalArgumentException("name expected")
     }
     ```
   - A ?: B <- 값이 null이라면 B 연산 수행하고 아닌 경우 A 연산 수행
  
* '!!' - double-bang 연산자
  - non-null 단언 연산자.
    
* 'as?'-Safe Cast
  ```kotlin
  val aInt: Int? = a as? Int
  ```
  -안전한 캐스팅 연산자. 실패하는 경우 자동적으로 null이 할당 됨.(NPE 없음)

* filterNotNull:
  - Collection의 경우, null element를 필터링하기 위하여 쓴다
  - ex) val intList: List<Int> = nullableList.filterNotNull()


# 상호 운용성
   자바와 코틀린은 100%호환된다. 코틀린을 쓸 때도 자바 라이브러리와 클래스 사용 가능하다. 
   또한 프로그램 개발 시 두 코드를 혼합해도 가능하다.
   결국에는 JVM에서 돌아가기 때문인것같다.
   현재는 추가적으로 js 플랫폼이나 네이티브 애플리케이션 c/c++,오브젝티브c,Swift와도 상호작용이 가능하다.

# 구조화 동시성
* 코루틴(CoRoutine)
     - 비동기 프로그래밍을 간소화할 수 있음.
> https://kotlinlang.org/docs/coroutines-basics.html#extract-function-refactoring

-----
# 코틀린 기초 문법




