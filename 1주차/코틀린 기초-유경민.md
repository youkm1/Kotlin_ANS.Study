1주차 

주제:장점, 차이점 그리고 코틀린의 기초 문법  by 유경민

코틀린은 우선 자바를 대체하고자 나온 언어이다. 
그러나 코틀린 또한 자바 가상 머신(JVM)을 사용한다. 

![image](https://github.com/youkm1/Kotlin_ANS.Study/assets/77780624/391f2aaf-cce5-4a71-a6e5-9033d654d172)<tr>



</tr>그렇다면 같은 머신 아래 왜 코틀린이 태어나야 했을까.


# 간결한 표현성
----
코틀린에서는 자바의 게터, 세터, 익명클래스, 명시적인 위임 등을 지양한다.

## 1. Getter/Setter
   Java는 객체의 무결성을 위해 게세터를 쓴다. 하지만 코틀린은 자동적으로 게세터가 생성된다(auto-generated Getter/Setter)
</br>따라서,
 ```Java
public class Car{
   private int car;
   public int getCar(){
      return car;
   }
   public void setCar(int car){
      if (car < 0):
         this.car = 0;
      else:
         this.car = car;
   }
}
```
⬇️

```kotlin
class Car(int car){
 // 코틀린. 개굿.
 }
```

물론, 스프링의 경우 갓Lombok가 있어서 어노테이션으로 처리가 가능하다. 
그것은 스프링의 오픈소스 라이브러리로 논외. 
</br>
## 2. 익명클래스
   익명클래스는 일회용 클래스로, 유지보수하지 않아도 될 때 쓰인다. 
Kotlin의 경우, object 키워드를 사용한다.

```kotlin
abstract class Doc{
   val title: String,
   val author: String,
   val words: Long = 0L
} {
   abstract fun summary():String
}
```
해당 클래스를 상속하는 => 익명 클래스를 만들겠다.
```kotlin
val article = object:Doc(title="매일경제", author="유경민", words="Kogood"){
   overrid fun summary() = "Title:<$title> ($words words) By $author"
}
```
class가 아닌 interface를 상속하기도 가능하다.

#  널 안정성
   객체지향에서 객체는 널 상태일 때 NullPointException이 발생한다. Kotlin에서는 변수를 널 허용(nullable)과 널 불가능(not null)으로 구분해 놓는다. 
```kotlin
var nullx: String = null //Err. default값은 not null임을 확인할 수 있음
var nullo: String? = null //nullable 위해서 물음표 필요함
```
</U>코틀린에서 널 값 안전히 처리하는 방법

# 상호 운용성

# 구조화 동시성
* 코루틴(CoRoutine)


