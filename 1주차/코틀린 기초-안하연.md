# 3장
## 03-1 코틀린 언어 소개
- JVM에 기반을 둔 언어
- .kt 확장자 사용
- 안드로이드 앱 개발 공식 언어

<br>

### 자바와 비교했을 때의 이점
* 표현력, 간결함
    - 자바에 비해 간결한 코드로 작성 가능
* 안전한 코드
    - 널 안정성 지원
    - 널 허용nullable/널 불허용not null으로 변수 구분해 선언
* 상호 운용성
    - 자바와 **100%** 호환
* 구조화 동시성
    - 코루틴 기법
        + 비동기 프로그래밍 간소화

<br>

### 코틀린 파일 구성
* package
* import 구문
    - 두 코틀린 파일이 같은 package 내에 있다면 import 없이 사용 가능
* var 변수
* fun 함수
* class

<br>

📌 **코틀린 파일명은 클래스명과 다르게 선언해도 된다.**
변수, 함수를 클래스로 묶지 않고 최상위에 선언할 수 있음   
코틀린 컴파일러 덕분에 자바에서 이용할 때도 문제 되지 않음

<br>

## 03-2 변수와 함수
### 변수 선언
* val 키워드
    - 초깃값이 할당되면 바꿀 수 없는 변수
* var 키워드
    - 초깃값이 할당된 후에도 값을 바꿀 수 있는 변수

```
val(혹은 var) 변수명: 타입 = 값
```

대입하는 값에 따라 타입 유추가 가능한 경우엔 타입 명시(:) 생략 가능

<br>

최상위에 선언한 변수/클래스의 멤버 변수는 선언과 동시에 초깃값 할당해야 함   
함수 내부에 선언한 변수는 선언만 하는 것 가능   
변수 초깃값을 할당할 수 없는 경우 ```lateinit```, ```lazy``` 키워드를 사용해 초기화 미루기 가능

* lateinit 키워드
    - ```var``` 키워드로 선언한 변수에만 사용 가능
    - ```Int```, ```Long```, ```Short```, ```Double```, ```Boolean```, ```Byte``` 타입에는 사용 불가
    ```
    lateinit var data: String
    ```
* lazy 키워드
    - ```by lazy {}``` 형식
    - 소스에서 변수가 최초로 이용되는 순간 중괄호로 묶은 부분이 자동 실행
    ```
    val data1: Int by lazy {
        println("in lazy...")
        10
    }
    ```

<br>

### 데이터 타입
📌 **코틀린의 모든 변수는 객체**   
코틀린의 모든 변수는 객체 타입. null 대입 가능   
ex. 정수를 다루는 Int 타입의 경우 기초 데이터 타입이 아닌 **클래스**

<br>

**기초 타입 객체**
- Int
- Short
- Long
- Double
- Float
- Byte
- Boolean

<br>

**문자, 문자열**
- Char
- String
    + **$**, **${}** 기호를 사용해 변숫값이나 어떤 연관식의 결과값 포함 가능
    ```
    println("name: $name, sum: ${sum(10)}")
    ```

<br>

**모든 타입 가능**
- Any
    + 코틀린에서 최상위 클래스

<br>

**반환문이 없는 함수**
- Unit
    + 특수한 상황 표현 목적으로 사용
    + Unit 타입으로 선언한 변수에는 Unit 객체만 대입 가능
        + 따라서 Unit 타입으로 변수 선언하는 것엔 의미가 없음
    + 주로 함수의 반환 타입으로 사용
    + 함수 선언 때 반환 타입 생략 시 자동으로 적용됨

<br>

**null, 예외 반환 함수**
- Nothing
    + 특수한 상황 표현 목적으로 사용
    + Nothing으로 선언한 변수에는 null만 대입 가능
        + 데이터로써의 의미 X
    + 주로 함수의 반환 타입으로 사용
        + 반환은 하지만 의미 있는 값은 아니라는 의미
        + 항상 *null*만 반환하는 함수 / *예외*를 던지는 함수

<br>

**널 허용, 불허용**
코틀린의 모든 타입은 객체이므로 변수에 null 대입 가능   
따라서 널 허용과 널 불허용을 명확히 구분해야 함
- 타입 뒤에 **?** 기호 추가 시 널 허용
```
var data1: Int = 10
data1 = null    // 오류 발생

var data2: Int? = 10
data2 = null
```

<br>

**함수 선언**
- fun
함수의 매개변수에는 ```var```, ```val``` 키워드 사용 불가. **val** 자동 적용
- 함수의 매개변수에 기본값 적용 가능
```
fun some(data1: Int, data2: Int = 10): Int {
    ...
}
```
- 함수 호출 시 매개변수명 지정 가능 = **명명된 매개변수**
    + 매개변수 순서 안 맞춰도 됨
```
some(data2 = 20, data1 = 10)
```

<br>

**컬렉션 타입**
- Array
    + 배열 타입은 제네릭으로 명시
    + 각 기초 타입의 배열을 나타내는 클래스를 이용할 수 있음(BooleanArray, ByteArray, ...)
    + ```arrayOf()``` 함수 이용해 배열 선언 시 값 할당 가능
        + 기초 타입 대상 함수 제공
- List
- Set
- Map

<br>

## 03-3 조건문과 반복문
### 조건문 if~else
프로그램 흐름을 제어하는 데에 가장 많이 사용   
표현식으로도 사용 가능
- 표현식 = 결괏값을 반환하는 계산식

<br>

### 조건문 when
매개변수로 넣은 데이터가 조건이 됨   
값에 따라 각 구문 실행
```
fun main() {
    var data = 10;
    when(data) {
        10 -> ...
        20 -> ...
        else -> {
            ...
        }
    }
}
```
- 데이터 타입 다양하게 지정 가능
- ```Any``` 사용 가능
- 데이터 명시하지 않고 조건만 명시해도 됨

<br>

### 반복문 for, while
```
for (i in 1..10) {...}          // 1부터 10까지 1씩 증가
for (i in 1 until 10) {...}     // 1부터 9까지 1씩 증가
for (i in 2..10 step 2) {...}   // 2부터 10까지 2씩 증가
for (i in 10 downTo 1) {...}    // 10부터 1까지 1씩 감소
for (i in array.indices) {...}    // 컬렉션 타입 데이터 개수만큼 반복
for ((index, value) in array.withIndex()) {...}    // 인덱스와 실제 데이터 함께 가져오기
```
**while문**은 조건이 참이면 중괄호{}로 지정한 영역 반복 실행

<br>
<br>

# 4장
## 04-1 클래스와 생성자